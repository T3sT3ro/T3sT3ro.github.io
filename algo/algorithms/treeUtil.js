function toTree(parentArray) {
    let G = {};
    Object.defineProperty(G, "size", { enumerable: false, writable: true });
    Object.defineProperty(G, "root", { enumerable: false, writable: true });
    G.size = parentArray.length;
    parentArray.forEach((p, c) => {
        if (p != -1) {
            G[p] = G[p] ?? [];
            G[p].push(c);
        } else {
            G.root = c;
        }
    });
    return G;
}

function toParentArray(tree) {
    let t = [];
    Object.entries(tree).forEach(([p, cx]) => cx.forEach(c => t[c] = +p));
    t[tree.root] = -1;
    return t;
}

// Random forest can be generated by cutting edges of random tree.
//  But this approach would result in very skewed distribution, where most trees are small.
//  For example in full binary tree, the probability of cutting an edge just under root would be 2/n ~= 0%, 
//  while cutting leafs 50%.
// One way to fix this could be choosing edges to cut from weighted probability,
//  for example edge at distance d from root has weight 1/(#nodes of edges at distance d)
// Another way is to generate trees separately, but in this approach there is less control over tree heights in the forest


// trivial implementation in n log n would use priority queue or smh, but I use O(n) solution
function toPruferCode(parentArray) {
    // TODO
}