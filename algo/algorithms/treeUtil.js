function parentsToTree(parentArray) {
    let G = {};
    Object.defineProperty(G, "size", { enumerable: false, writable: true });
    G.size = parentArray.length;
    parentArray.forEach((p, c) => {
        if (p != -1) {
            G[p] = (G[p] ?? []).concat([c]);
            G[c] = (G[c] ?? []).concat([p]);
        }
    });
    return G;
}

function treeToParents(tree, root = 0) {
    let parent = [];
    function dfs(v) {
        for (const u of tree[v]) {
            if (u != parent[v]) {
                parent[u] = v;
                dfs(u);
            }
        }
    }
    parent[root] = -1;
    dfs(root);
    return parent;
}

// Random forest can be generated by cutting edges of random tree.
//  But this approach would result in very skewed distribution, where most trees are small.
//  For example in full binary tree, the probability of cutting an edge just under root would be 2/n ~= 0%, 
//  while cutting leafs 50%.
// One way to fix this could be choosing edges to cut from weighted probability,
//  for example edge at distance d from root has weight 1/(#nodes of edges at distance d)
// Another way is to generate trees separately, but in this approach there is less control over tree heights in the forest


// trivial implementation in n log n would use priority queue or smh, but I use O(n) solution
// https://cp-algorithms.com/graph/pruefer_code.html
function toPruferCode(tree) {
    let [ptr, degree, parent] = [-1, [], treeToParents(tree, tree.size - 1)];
    for (const i in parent) {
        degree[i] = tree[i].length;
        if (tree[i].length == 1 && ptr == -1)
            ptr = i;
    }
    let [leaf, code] = [ptr, []];
    for (let i = 0; i < tree.size - 2; ++i) {
        let next = parent[leaf];
        code[i] = next;
        if (--degree[next] == 1 && next < ptr) {
            leaf = next;
        } else {
            do { ++ptr } while (degree[ptr] != 1);
            leaf = ptr;
        }
    }
    return code;
}

function fromPruferCode(code) {
    let [ptr, degree] = [-1, [...new Array(code.length).fill(1)]];
    for(const node of code)
        ++degree[code];
    for(const i in code)
        if(degree[code[i]] == 1 && ptr == -1)
            ptr = i;
    //  TODO
}